<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CPP之vector容器小结</title>
      <link href="/2020/01/02/cpp-zhi-vector-rong-qi-xiao-jie/"/>
      <url>/2020/01/02/cpp-zhi-vector-rong-qi-xiao-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CPP之map用法总结</title>
      <link href="/2020/01/02/cpp-zhi-map-yong-fa-zong-jie/"/>
      <url>/2020/01/02/cpp-zhi-map-yong-fa-zong-jie/</url>
      
        <content type="html"><![CDATA[<center><font color="purple" size="6">C++中map用法总结</font></center><h4 id="1-map简介"><a href="#1-map简介" class="headerlink" title="1. map简介"></a>1. map简介</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">map是C++STL（标准模板库）的一个关联容器，它提供一对一的hash。</font></p><p>&#160; &#160; &#160; &#160;<font color="black" size="4">(1).第一个可以称为关键字(key)，每个关键字只能在map中出现一次；</font></p><p>&#160; &#160; &#160; &#160;<font color="black" size="4">(2).第二个可能称为该关键字的值(value)；</font></p><p>&#160; &#160; &#160; &#160; <font color="black" size="4">map以模板(泛型)方式实现，可以存储任意类型的数据，包括使用者自定义的数据类型。Map主要用于资料一对一映射(one-to-one)的情況，map內部的实现自建一颗红黑树，这颗树具有对数据自动排序的功能。在map内部所有的数据都是有序的，后边我们会见识到有序的好处。比如一个班级中，每个学生的学号跟他的姓名就存在著一对一映射的关系。</font></p><p><img src="1.png" alt></p><h4 id="2-map的功能"><a href="#2-map的功能" class="headerlink" title="2. map的功能"></a>2. map的功能</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">自动建立key － value的对应。key 和 value可以是任意你需要的类型。</font></p><h4 id="3-map的使用"><a href="#3-map的使用" class="headerlink" title="3. map的使用"></a>3. map的使用</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">使用map得包含map类所在的头文件： </font></p><pre class="line-numbers language-c++"><code class="language-c++">#include <map>  //注意，STL头文件没有扩展名.h<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&#160; &#160; &#160; &#160;<font color="black" size="4">map对象是模板类，需要关键字和存储对象两个模板参数,如下图所示，这样就定义了一个用int作为索引,并拥有相关联的指向string的指针.</font></p><pre class="line-numbers language-c++"><code class="language-c++">std:map<int, string> personnel;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&#160; &#160; &#160; &#160;<font color="black" size="4">为了使用方便，可以对模板类进行一下类型定义：</font></p><pre class="line-numbers language-c++"><code class="language-c++">typedef map<int,CString> UDT_MAP_INT_CSTRING;UDT_MAP_INT_CSTRING enumMap;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="4-map的构造函数"><a href="#4-map的构造函数" class="headerlink" title="4. map的构造函数"></a>4. map的构造函数</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">map共提供了6个构造函数，这块涉及到内存分配器这些东西，略过不表，在下面我们将接触到一些map的构造方法，这里要说下的就是，我们通常用如下方法构造一个map： </font></p><pre class="line-numbers language-c++"><code class="language-c++">map<int, string> mapStudent;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="5-插入元素"><a href="#5-插入元素" class="headerlink" title="5. 插入元素"></a>5. 插入元素</h4><pre class="line-numbers language-c++"><code class="language-c++">// 定义一个map对象map<int, string> mapStudent;// 第一种 用insert函數插入pairmapStudent.insert(pair<int, string>(000, "student_zero"));// 第二种 用insert函数插入value_type数据mapStudent.insert(map<int, string>::value_type(001, "student_one"));// 第三种 用"array"方式插入mapStudent[123] = "student_first";mapStudent[456] = "student_second";<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><font color="black" size="4">以上三种用法，虽然都可以实现数据的插入，但是它们是有区别的，当然了第一种和第二种在效果上是完成一样的，用insert函数插入数据，在数据的插入上涉及到集合的唯一性这个概念，<font color="red" size="4">即当map中有这个关键字时，insert操作是不能在插入数据的，</font>但是用数组方式就不同了，它可以覆盖以前该关键字对 应的值，用程序说明如下：</font></p><pre class="line-numbers language-c++"><code class="language-c++">mapStudent.insert(map<int, string>::value_type (001, "student_one"));mapStudent.insert(map<int, string>::value_type (001, "student_two"));<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><font color="black" size="4">上面这两条语句执行后，map中001这个关键字对应的值是“student_one”，第二条语句并没有生效，那么这就涉及到我们怎么知道insert语句是否插入成功的问题了，可以用pair来获得是否插入成功，程序如下:   我们通过pair的第二个变量来知道是否插入成功，它的第一个变量返回的是一个map的迭代器，如果插入成功的话Insert_Pair.second应该是true的，否则为false。</font></p><pre class="line-numbers language-c++"><code class="language-c++">// 构造定义，返回一个pair对象pair<iterator,bool> insert (const value_type& val);pair<map<int, string>::iterator, bool> Insert_Pair;Insert_Pair = mapStudent.insert(map<int, string>::value_type (001, "student_one"));if(!Insert_Pair.second)    cout << ""Error insert new element" << endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="6-查找元素"><a href="#6-查找元素" class="headerlink" title="6. 查找元素"></a>6. 查找元素</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">当所查找的关键key出现时，它返回数据所在对象的位置，如果沒有，返回iter与end函数的值相同。 </font></p><pre class="line-numbers language-c++"><code class="language-c++">// find 返回迭代器指向当前查找元素的位置否则返回map::end()位置iter = mapStudent.find("123");if(iter != mapStudent.end())       cout<<"Find, the value is"<<iter->second<<endl;else   cout<<"Do not Find"<<endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="7-刪除与清空元素"><a href="#7-刪除与清空元素" class="headerlink" title="7. 刪除与清空元素"></a>7. 刪除与清空元素</h4><pre class="line-numbers language-c++"><code class="language-c++">//迭代器刪除iter = mapStudent.find("123");mapStudent.erase(iter);//用关键字刪除int n = mapStudent.erase("123"); //如果刪除了會返回1，否則返回0//用迭代器范围刪除 : 把整个map清空mapStudent.erase(mapStudent.begin(), mapStudent.end());//等同于mapStudent.clear()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="8-map的大小"><a href="#8-map的大小" class="headerlink" title="8. map的大小"></a>8. map的大小</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">在往map里面插入了数据，我们怎么知道当前已经插入了多少数据呢，可以用size函数，用法如下：</font></p><pre class="line-numbers language-c++"><code class="language-c++">int nSize = mapStudent.size();<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="9-map的基本操作函数："><a href="#9-map的基本操作函数：" class="headerlink" title="9. map的基本操作函数："></a>9. map的基本操作函数：</h4><pre class="line-numbers language-c++"><code class="language-c++">     C++ maps是一种关联式容器，包含“关键字/值”对     begin()         返回指向map头部的迭代器     clear(）        删除所有元素     count()         返回指定元素出现的次数     empty()         如果map为空则返回true     end()           返回指向map末尾的迭代器     equal_range()   返回特殊条目的迭代器对     erase()         删除一个元素     find()          查找一个元素     get_allocator() 返回map的配置器     insert()        插入元素     key_comp()      返回比较元素key的函数     lower_bound()   返回键值>=给定元素的第一个位置     max_size()      返回可以容纳的最大元素个数     rbegin()        返回一个指向map尾部的逆向迭代器     rend()          返回一个指向map头部的逆向迭代器     size()          返回map中元素的个数     swap()           交换两个map     upper_bound()    返回键值>给定元素的第一个位置     value_comp()     返回比较元素value的函数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++中堆和栈的区别</title>
      <link href="/2020/01/02/cpp-zhong-dui-he-zhan-de-qu-bie/"/>
      <url>/2020/01/02/cpp-zhong-dui-he-zhan-de-qu-bie/</url>
      
        <content type="html"><![CDATA[<center><font color="purple" size="6">C++中关于堆和栈的区别</font></center><h6 id="1-在C-中，内存分成5个区，他们分别是堆、栈、自由存储区、全局-静态存储区和常量存储区。"><a href="#1-在C-中，内存分成5个区，他们分别是堆、栈、自由存储区、全局-静态存储区和常量存储区。" class="headerlink" title="1. 在C++中，内存分成5个区，他们分别是堆、栈、自由存储区、全局/静态存储区和常量存储区。 "></a>1. 在C++中，内存分成5个区，他们分别是<font color="red">堆、栈、自由存储区、全局/静态存储区和常量存储区。 </font></h6><h6 id="2-栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。"><a href="#2-栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。" class="headerlink" title="2. 栈，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。"></a>2. <font color="red">栈</font>，就是那些由编译器在需要的时候分配，在不需要的时候自动清除的变量的存储区。里面的变量通常是局部变量、函数参数等。</h6><h6 id="3-堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。"><a href="#3-堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。" class="headerlink" title="3. 堆，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。"></a>3. <font color="red">堆</font>，就是那些由new分配的内存块，他们的释放编译器不去管，由我们的应用程序去控制，一般一个new就要对应一个delete。如果程序员没有释放掉，那么在程序结束后，操作系统会自动回收。</h6><h6 id="4-自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。"><a href="#4-自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。" class="headerlink" title="4. 自由存储区，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。"></a>4. <font color="red">自由存储区</font>，就是那些由malloc等分配的内存块，他和堆是十分相似的，不过它是用free来结束自己的生命的。</h6><h6 id="5-全局-静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过void-来访问和操纵，程序结束后由系统自行释放），在C-里面没有这个区分了，他们共同占用同一块内存区。"><a href="#5-全局-静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过void-来访问和操纵，程序结束后由系统自行释放），在C-里面没有这个区分了，他们共同占用同一块内存区。" class="headerlink" title="5. 全局/静态存储区，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过void*来访问和操纵，程序结束后由系统自行释放），在C++里面没有这个区分了，他们共同占用同一块内存区。"></a>5. <font color="red">全局/静态存储区</font>，全局变量和静态变量被分配到同一块内存中，在以前的C语言中，全局变量又分为初始化的和未初始化的（初始化的全局变量和静态变量在一块区域，未初始化的全局变量与静态变量在相邻的另一块区域，同时未被初始化的对象存储区可以通过void*来访问和操纵，程序结束后由系统自行释放），在C++里面没有这个区分了，他们共同占用同一块内存区。</h6><h6 id="6-常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）"><a href="#6-常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）" class="headerlink" title="6. 常量存储区，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）"></a>6. <font color="red">常量存储区</font>，这是一块比较特殊的存储区，他们里面存放的是常量，不允许修改（当然，你要通过非正当手段也可以修改，而且方法很多）</h6><h6 id="7-管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆-来说，释放工作由程序员控制，容易产生memory-leak。"><a href="#7-管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆-来说，释放工作由程序员控制，容易产生memory-leak。" class="headerlink" title="7. 管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆 来说，释放工作由程序员控制，容易产生memory leak。"></a>7. 管理方式不同：对于栈来讲，是由编译器自动管理，无需我们手工控制；对于堆 来说，释放工作由程序员控制，容易产生memory leak。</h6><h6 id="8-碎片问题：对于堆来讲，频繁的new-delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。"><a href="#8-碎片问题：对于堆来讲，频繁的new-delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。" class="headerlink" title="8.碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。"></a>8.碎片问题：对于堆来讲，频繁的new/delete势必会造成内存空间的不连续，从而造成大量的碎片，使程序效率降低。对于栈来讲，则不会存在这个问题，因为栈是先进后出的队列，他们是如此的一一对应，以至于永远都不可能有一个内存块从栈中间弹出，在他弹出之前，在他上面的后进的栈内容已经被弹出。</h6><h6 id="9-生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。"><a href="#9-生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。" class="headerlink" title="9. 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。"></a>9. 生长方向：对于堆来讲，生长方向是向上的，也就是向着内存地址增加的方向；对于栈来讲，它的生长方向是向下的，是向着内存地址减小的方向增长。</h6><h6 id="10-分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。"><a href="#10-分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。" class="headerlink" title="10. 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。"></a>10. 分配方式：堆都是动态分配的，没有静态分配的堆。栈有2种分配方式：静态分配和动态分配。静态分配是编译器完成的，比如局部变量的分配。动态分配由alloca函数进行分配，但是栈的动态分配和堆是不同的，他的动态分配是由编译器进行释放，无需我们手工实现。</h6><h6 id="11-new-amp-delete和malloc-amp-free的联系与区别："><a href="#11-new-amp-delete和malloc-amp-free的联系与区别：" class="headerlink" title="11. new&amp;delete和malloc&amp;free的联系与区别："></a>11. <font color="red" size="4">new&amp;delete和malloc&amp;free的联系与区别：</font></h6><p>&#160; &#160; &#160; &#160;(1).new和malloc都是申请内存空间，分配的空间都在堆存储区。 </p><p>&#160; &#160; &#160; &#160;(2).new的时候会初始化内存空间，而malloc只是申请了内存空间，不进行初始化；同时，delete会调用析构函数，而free只是释放内存空间，指针还在（因此free之后，还需要设置指针为NULL）。 </p><p>&#160; &#160; &#160; &#160;(3).malloc&amp;free是C/C++的标准库函数，而new&amp;delete是C++的运算符。</p>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cpp之指针小结</title>
      <link href="/2019/12/27/cpp-zhi-zhi-zhen-xiao-jie/"/>
      <url>/2019/12/27/cpp-zhi-zhi-zhen-xiao-jie/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Python面向对象之self和init之解析</title>
      <link href="/2019/12/26/python-mian-xiang-dui-xiang-zhi-self-he-init-zhi-jie-xi/"/>
      <url>/2019/12/26/python-mian-xiang-dui-xiang-zhi-self-he-init-zhi-jie-xi/</url>
      
        <content type="html"><![CDATA[<center><font color="purple" size="6">Python面向对象之self和__init__()之解析</font></center><center><font color="purple" size="6">一、Python面向对象之self</font></center><h4 id="1-self是什么"><a href="#1-self是什么" class="headerlink" title="1. self是什么"></a>1. self是什么</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">Python的self其实就相当于C++的this指针。如果把类比作是图纸，那么由类实例化后的对象才是真正可以住的房子。根据一张图纸可以设计出成千上万的房子，它们长得都差不多，但它们都有不同的主人。每个人都只能回自己的家里，陪伴自己的孩子。。。。。。所以self这里就相当于每个房子的门牌号，有了self，你就可以轻松找到自己的房子。 </font><br>&#160; &#160; &#160; &#160;<font color="red" size="4">Python的self参数就是用一个道理，由同一个类可以生成无数对象，当一个对象的方法被调用的时候，对象会将自身的引用作为第一个参数传给该方法，那么Python就知道需要操作哪个对象的方法了。如下面的例子： </font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Ball</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">setName</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name    <span class="token keyword">def</span> <span class="token function">kick</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"我叫 %s, 嗷~谁踢我？！"</span> <span class="token operator">%</span>self<span class="token punctuation">.</span>name<span class="token punctuation">)</span>a <span class="token operator">=</span> Ball<span class="token punctuation">(</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>setName<span class="token punctuation">(</span><span class="token string">"飞火流星"</span><span class="token punctuation">)</span>b <span class="token operator">=</span> Ball<span class="token punctuation">(</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span>setName<span class="token punctuation">(</span><span class="token string">"团队之星"</span><span class="token punctuation">)</span>c <span class="token operator">=</span> Ball<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>setName<span class="token punctuation">(</span><span class="token string">"土豆"</span><span class="token punctuation">)</span>a<span class="token punctuation">.</span>kick<span class="token punctuation">(</span><span class="token punctuation">)</span>b<span class="token punctuation">.</span>kick<span class="token punctuation">(</span><span class="token punctuation">)</span>c<span class="token punctuation">.</span>kick<span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-self代表类的实例，而非类"><a href="#2-self代表类的实例，而非类" class="headerlink" title="2. self代表类的实例，而非类"></a>2. self代表类的实例，而非类</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的第一个参数名称, 按照惯例它的名称是self。</font></p><center><font color="purple" size="6">二、Python面向对象之__init__()</font></center><h4 id="init-方法是构造方法"><a href="#init-方法是构造方法" class="headerlink" title="init()方法是构造方法"></a><strong>init</strong>()方法是构造方法</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">类有一个名为<strong>init</strong>() 的特殊方法（构造方法），该方法在类实例化时会自动调用。由于类起到模板的作用，因此，可以在创建实例的时候，把我们认为必须绑定的属性强制填写进去。这里就用到Python当中的一个内置方法<strong>init</strong>方法，例如在Student类时，把name、score等属性绑上去:</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Student</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> name<span class="token punctuation">,</span> score<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>name <span class="token operator">=</span> name        self<span class="token punctuation">.</span>score <span class="token operator">=</span> scorestudent <span class="token operator">=</span> Student<span class="token punctuation">(</span><span class="token string">"Hugh"</span><span class="token punctuation">,</span> <span class="token number">99</span><span class="token punctuation">)</span>student<span class="token punctuation">.</span>namestudent<span class="token punctuation">.</span>score<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#160; &#160; &#160; &#160;<font color="red" size="4">这里需要注意：(1) <strong>init</strong>方法的第一参数永远是self，表示创建的类实例本身，因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。(2)有了<strong>init</strong>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<strong>init</strong>方法匹配的参数，但self不需要传，Python解释器会自己把实例变量传进去：</font></p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode第一题两数之和</title>
      <link href="/2019/12/24/leetcode-di-yi-ti-liang-shu-zhi-he/"/>
      <url>/2019/12/24/leetcode-di-yi-ti-liang-shu-zhi-he/</url>
      
        <content type="html"><![CDATA[<center><font color="purple" size="6">LeetCode第一题两数之和</font></center>&#160; &#160; &#160; &#160;<font color="black" size="4">给定一个整数数组nums和一个目标值target，请你在该数组中找出和为目标值的那两个整数，并返回他们的数组下标。你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</font><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><p>&#160; &#160; &#160; &#160;<font color="black" size="4">下面给出基于C++和Python两种解题思路</font></p><center><font color="purple" size="6">C++解法</font></center><h4 id="解法一：暴力法"><a href="#解法一：暴力法" class="headerlink" title="解法一：暴力法"></a>解法一：暴力法</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">分析：题目给定我们一个数组nums和一个目标值target，那我们可以用两个for循环遍历所有的结果，然后返回两数之和等于目标值的两个数的下标即可。如下解法，其中nums.size()是获取向量元素个数。</font><br><img src="001.JPG" alt></p><h4 id="解法二：两遍哈希表"><a href="#解法二：两遍哈希表" class="headerlink" title="解法二：两遍哈希表"></a>解法二：两遍哈希表</h4><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        map<int,int> a;//建立hash表存放数组元素        vector<int> b(2,-1);//存放结果        for(int i=0;i<nums.size();i++)            a.insert(map<int,int>::value_type(nums[i],i));        for(int i=0;i<nums.size();i++)        {            if(a.count(target-nums[i])>0&&(a[target-nums[i]]!=i))            //判断是否找到目标元素且目标元素不能是本身            {                b[0]=i;                b[1]=a[target-nums[i]];                break;            }        }        return b;    };};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>&#160; &#160; &#160; &#160;<font color="black" size="4">该方法用map实现，map是STL的一个关联容器，它提供一对一（其中第一个可以称为关键字，每个关键字只能在map中出现一次，第二个可能称为该关键字的值）的数据处理能力。（我们下一篇博文重点介绍C++map函数以及vector）。</font></p><h4 id="解法三：一遍哈希表"><a href="#解法三：一遍哈希表" class="headerlink" title="解法三：一遍哈希表"></a>解法三：一遍哈希表</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">改进：在进行迭代并将元素插入到表中的同时，我们还会回过头来检查表中是否已经存在当前元素所对应的目标元素。如果它存在，那我们已经找到了对应解，并立即将其返回。</font></p><pre class="line-numbers language-c++"><code class="language-c++">class Solution {public:    vector<int> twoSum(vector<int>& nums, int target) {        map<int,int> a;//提供一对一的hash        vector<int> b(2,-1);//用来承载结果，初始化一个大小为2，值为-1的容器b        for(int i=0;i<nums.size();i++)        {            if(a.count(target-nums[i])>0)            {                b[0]=a[target-nums[i]];                b[1]=i;                break;            }            a[nums[i]]=i;//反过来放入map中，用来获取结果下标        }        return b;    };};<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><center><font color="purple" size="6">Python解法</font></center><h4 id="解法一："><a href="#解法一：" class="headerlink" title="解法一："></a>解法一：</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">遍历列表同时查字典</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        dct <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> i<span class="token punctuation">,</span> n <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> target <span class="token operator">-</span> n <span class="token keyword">in</span> dct<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>dct<span class="token punctuation">[</span>target <span class="token operator">-</span> n<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">]</span>            dct<span class="token punctuation">[</span>n<span class="token punctuation">]</span> <span class="token operator">=</span> i<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法二："><a href="#解法二：" class="headerlink" title="解法二："></a>解法二：</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">解题关键主要是想找到 num2 = target - num1，是否也在 list 中，那么就需要运用以下两个方法：<br><em>num2 in nums，返回True说明有戏</em>nums.index(num2)，查找num2的索引<br></font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        lens <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        j<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>lens<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> nums<span class="token punctuation">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">.</span>count<span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">&amp;</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#如果num2=num1,且nums中只出现了一次，说明找到是num1本身。</span>                    <span class="token keyword">continue</span>                <span class="token keyword">else</span><span class="token punctuation">:</span>                    j <span class="token operator">=</span> nums<span class="token punctuation">.</span>index<span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span>i<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">#index(x,i+1)是从num1后的序列后找num2                </span>                    <span class="token keyword">break</span>        <span class="token keyword">if</span> j<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法三："><a href="#解法三：" class="headerlink" title="解法三："></a>解法三：</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">解题思路是在方法二的基础上，优化解法。想着，num2的查找并不需要每次从nums查找一遍，只需要从num1位置之前或之后查找即可。但为了方便 index 这里选择从num1 位置之前查找：</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        lens <span class="token operator">=</span> len<span class="token punctuation">(</span>nums<span class="token punctuation">)</span>        j<span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span>lens<span class="token punctuation">)</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> nums<span class="token punctuation">[</span><span class="token punctuation">:</span>i<span class="token punctuation">]</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">in</span> temp<span class="token punctuation">:</span>                j <span class="token operator">=</span> temp<span class="token punctuation">.</span>index<span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token keyword">break</span>        <span class="token keyword">if</span> j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>j<span class="token punctuation">,</span>i<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法四："><a href="#解法四：" class="headerlink" title="解法四："></a>解法四：</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">参考了大神们的解法，通过哈希来求解，这里通过字典来模拟哈希查询的过程。个人理解这种办法相较于方法一其实就是字典记录了num1和num2的值和位置，而省了再查找num2索引的步骤。</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">class</span> <span class="token class-name">Solution</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> nums<span class="token punctuation">:</span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">,</span> target<span class="token punctuation">:</span> int<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> List<span class="token punctuation">[</span>int<span class="token punctuation">]</span><span class="token punctuation">:</span>        hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">for</span> ind<span class="token punctuation">,</span>num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            hashmap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> ind        <span class="token keyword">for</span> i<span class="token punctuation">,</span>num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>            j <span class="token operator">=</span> hashmap<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target <span class="token operator">-</span> num<span class="token punctuation">)</span>            <span class="token keyword">if</span> j <span class="token keyword">is</span> <span class="token operator">not</span> None <span class="token operator">and</span> i<span class="token operator">!=</span>j<span class="token punctuation">:</span>                <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span>j<span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="解法五："><a href="#解法五：" class="headerlink" title="解法五："></a>解法五：</h4><p>&#160; &#160; &#160; &#160;<font color="black" size="4">类似方法二，不需要mun2 不需要在整个dict中去查找。可以在num1之前的dict中查找，因此就只需要一次循环可解决。</font></p><pre class="line-numbers language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">twoSum</span><span class="token punctuation">(</span>nums<span class="token punctuation">,</span> target<span class="token punctuation">)</span><span class="token punctuation">:</span>    hashmap<span class="token operator">=</span><span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">for</span> i<span class="token punctuation">,</span>num <span class="token keyword">in</span> enumerate<span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> hashmap<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target <span class="token operator">-</span> num<span class="token punctuation">)</span> <span class="token keyword">is</span> <span class="token operator">not</span> None<span class="token punctuation">:</span>            <span class="token keyword">return</span> <span class="token punctuation">[</span>i<span class="token punctuation">,</span>hashmap<span class="token punctuation">.</span>get<span class="token punctuation">(</span>target <span class="token operator">-</span> num<span class="token punctuation">)</span><span class="token punctuation">]</span>        hashmap<span class="token punctuation">[</span>num<span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token comment" spellcheck="true">#这句不能放在if语句之前，解决list中有重复值或target-num=num的情况</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Sublime Text 配置C++和Python环境</title>
      <link href="/2019/12/22/sublime-text-pei-zhi-c-he-python-huan-jing/"/>
      <url>/2019/12/22/sublime-text-pei-zhi-c-he-python-huan-jing/</url>
      
        <content type="html"><![CDATA[<center><font color="purple" size="6">Sublime Text 配置C++和Python环境</font></center>&#160; &#160; &#160; &#160;<font color="black" size="4"> Sublime Text 是一款用于代码、标记和散文的<font color="red" size="4">精致文本编辑器</font>。具有漂亮的用户界面和强大的功能，例如代码缩略图，Python的插件，代码段等。还可自定义键绑定，菜单和工具栏。Sublime Text 的主要功能包括：拼写检查，书签，完整的 Python API ， Goto 功能，即时项目切换，多选择，多窗口等等。Sublime Text 是一个跨平台的编辑器，同时支持Windows、Linux、Mac OS X等操作系统。</font><p><img src="sublime.png" alt></p><p>&#160; &#160; &#160; &#160;<font color="black" size="4"> 相比于其他编程软件VS Code, Pycharm等等，<font color="red" size="4">Sublime Text更简洁，速度更快。</font>接下来我们就详细介绍如何基于Sublime Text 配置C++和Python环境。先附上一张美图，供大家参考，嘿嘿。</font><br><img src="sublimetext.JPG" alt></p><center><font color="purple" size="5">一、基于Sublime Text 配置C++环境</font></center>&#160; &#160; &#160; &#160;1. 安装Sublime Text 3，安装过程自行百度，这里不做过多讲解。<p>&#160; &#160; &#160; &#160;2. 配置C++运行环境</p><p>&#160; &#160; &#160; &#160; &#160;(I). 首先要安装C++的编译器,<br>常见的有MSVC、GCC、Cygwin、MinGW等等，大家选择一个安装就好。(我安装的是MinGW。)</p><p>&#160; &#160; &#160; &#160; &#160;(II). 装完编译器之后在我的电脑右键，依次点击属性-高级系统设置-环境变量，在系统变量中找到Path，编辑它，新建一条，添加MinGW的bin文件夹路径，以我的为例如下图：<br><img src="system.JPG" alt></p><p>&#160; &#160; &#160; &#160; &#160;(III). 打开Sublime Text，依次点击Tools - Build System - new Build System，粘贴以下代码并保存，如图：</p><pre><code>{    &quot;encoding&quot;: &quot;utf-8&quot;,    &quot;working_dir&quot;: &quot;$file_path&quot;,    &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,    &quot;selector&quot;: &quot;source.c++&quot;,    &quot;variants&quot;:     [        {           &quot;name&quot;: &quot;Run&quot;,            &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;${file_path}/${file_base_name}\&quot; &amp; pause\&quot;&quot;        }    ]}</code></pre><p><img src="c++.JPG" alt></p><p>&#160; &#160; &#160; &#160;(IV). 这时候配置就完成了。我们可以写一个test.cpp代码测试一下，然后Tools - Build System选择C++，然后按ctrl+b就可以运行了，如下图。<br><img src="helloc++.JPG" alt></p><center><font color="purple" size="5">二、基于Sublime Text 配置Python环境</font></center>&#160; &#160; &#160; &#160; 1. 配置Python的环境和C++大同小异，下面简要描述。<p>&#160; &#160; &#160; &#160; 2. 打开Sublime Text，依次点击Tools - Build System - new Build System，粘贴以下代码并保存，其中第一行为python解释器所在的目录，如图：</p><pre><code>{    &quot;cmd&quot;: [&quot;‪C:/Program Files/Python36/python.exe&quot;,&quot;-u&quot;,&quot;$file&quot;],    &quot;file_regex&quot;:&quot;^[ ]*File \&quot;(...*?)\&quot;, line ([0-9]*)&quot;,    &quot;selector&quot;:&quot;source.python&quot;,}</code></pre><p><img src="pythonsys.JPG" alt></p><p>&#160; &#160; &#160; &#160; 3. 这时候配置就完成了。我们可以写一个test.py代码测试一下，然后Tools - Build System选择python，然后按ctrl+b就可以运行了，如下图。<br><img src="hellopython.JPG" alt></p>]]></content>
      
      
      <categories>
          
          <category> Sublime Text </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Sublime Text </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Offer成长的起点</title>
      <link href="/2019/12/20/offer-cheng-chang-de-qi-dian/"/>
      <url>/2019/12/20/offer-cheng-chang-de-qi-dian/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=27896659&auto=1&height=66"></iframe></div><h2 id="“生活就是舞台，在每一处盛开。-你我为梦添色彩，无人可替代。。。。。。”-当写下这篇记录自己准备Offer的起点文章时，耳机里单曲循环着由央视著名主持人合唱的这首《生活就是舞台》。是啊，生活就是舞台，时刻充满期待。就比如当前的我，一无所知，对自己的未来没有准确清晰的定位，目前没有论文，没有专利，没有项目，有的只是一颗无所畏惧的心，一颗永不服输的心，还有那份执着吧！"><a href="#“生活就是舞台，在每一处盛开。-你我为梦添色彩，无人可替代。。。。。。”-当写下这篇记录自己准备Offer的起点文章时，耳机里单曲循环着由央视著名主持人合唱的这首《生活就是舞台》。是啊，生活就是舞台，时刻充满期待。就比如当前的我，一无所知，对自己的未来没有准确清晰的定位，目前没有论文，没有专利，没有项目，有的只是一颗无所畏惧的心，一颗永不服输的心，还有那份执着吧！" class="headerlink" title="“生活就是舞台，在每一处盛开。 你我为梦添色彩，无人可替代。。。。。。” 当写下这篇记录自己准备Offer的起点文章时，耳机里单曲循环着由央视著名主持人合唱的这首《生活就是舞台》。是啊，生活就是舞台，时刻充满期待。就比如当前的我，一无所知，对自己的未来没有准确清晰的定位，目前没有论文，没有专利，没有项目，有的只是一颗无所畏惧的心，一颗永不服输的心，还有那份执着吧！"></a><font color="black" size="5">“生活就是舞台，在每一处盛开。 你我为梦添色彩，无人可替代。。。。。。” 当写下这篇记录自己准备Offer的起点文章时，耳机里单曲循环着由央视著名主持人合唱的这首《生活就是舞台》。是啊，生活就是舞台，时刻充满期待。就比如当前的我，一无所知，对自己的未来没有准确清晰的定位，目前没有论文，没有专利，没有项目，有的只是一颗无所畏惧的心，一颗永不服输的心，还有那份执着吧！</font></h2><center><font color="black" size="6">Offer成长的起点</font></center>&#160; &#160; &#160; &#160;<font color="black" size="4">2019年还有10天左右就结束了它的生命周期，而自己也到了研二上学期的末尾，转眼就是毕业问题，毕业问题就是生存和发展问题。 记得还是从初中那会，父亲就常在学习上教导我：车轮不圆，早点转。那时，心里就暗暗下定决心，我要做自己的主人，相信汗水的过程！果不其然，初中的经历可以说是辉煌的，而现在的我是当年同等水平同学中发展还不错的。而这一次，即将站在人生的重要选择口，再一次回忆起父亲的教导，我想再来一次 <font color="red" size="4">“二次呼吸”</font>(自己发明的词语，源于初中连续三年参加校级冬季阳光体育运动长跑10KM的经验积累，内涵是：当听到发令枪响起，心跳加速，呼吸加速，到经历了平稳过度后，自主呼吸的结果，此刻心跳平稳，呼吸均匀，全身心的保持专注：长跑！)</font><h2 id="起于现在"><a href="#起于现在" class="headerlink" title="起于现在"></a>起于现在</h2><p>&#160; &#160; &#160; &#160;<font color="black" size="4">“什么时候开始都不算晚，要克服自己心里的畏惧感，多动手，多实践，你也可以的！” 这是目前对自己的激励，毕竟这个“起点”对我来说需要做很多工作，庆幸的是自己已经有了长跑的路线，接来下就是日复一日的坚持和付出。<br>&#160; &#160; &#160; &#160;暂时给自己定的目标: <strong>偏业务的算法工程师 &gt; 开发工程师</strong><br>&#160; &#160; &#160; &#160;通过一天的信息搜集整理，目前自己要先把基础打好，毕竟我们的手艺是 <strong>“coding”</strong>，下面是自己的学习内容：<br>&#160; &#160; &#160; &#160;(1) C++ Primer Plus (第6版) 中文版<br>&#160; &#160; &#160; &#160;(2) 数据结构 (C++语言版) 第3版 邓俊辉编著<br>&#160; &#160; &#160; &#160;(3) LeetCode<br>&#160; &#160; &#160; &#160;(4) 剑指Offer</font><br>&#160; &#160; &#160; &#160;<font color="black" size="4">这些资料，我这里都有PDF版本，有想要一起努力的小伙伴可以微信联系我，我私发给你百度云链接，顺便以书会友，加强技术的交流。</font><br><img src="C++.png" alt></p><h2 id="在于未来"><a href="#在于未来" class="headerlink" title="在于未来"></a>在于未来</h2><p>&#160; &#160; &#160; &#160;<font color="black" size="4"> <strong>“今天的挥汗如雨，是为了明天的挥金如土！”</strong> 今天开始，以后的每一天小亮都会在自己的个人博客里发布至少一篇博文记录自己的成长，记录自己的一点一滴。写到这里，又想起了自己的好基友“狗蛋”前几天提到的：所经历的都精彩！<br>&#160; &#160; &#160; &#160;加油吧！少年，曾经的 <strong>“试玉要烧三日满，辨材须待七年期”</strong>，现如今已剩下不到一年，是该兑现诺言的时候了。<br>&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160; &#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160; &#160; &#160; &#160;&#160;——2019年12月20日 己亥丙子辛卯 于北洋园</font></p>]]></content>
      
      
      <categories>
          
          <category> 成长 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 成长 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeetCode</title>
      <link href="/2019/12/18/leetcode/"/>
      <url>/2019/12/18/leetcode/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=191252&auto=1&height=66"></iframe></div><p>时间过得很快，已经到了研二上学期期末了。虽然已经快一年没有课，但是每天的生活依旧是匆匆忙忙的，无时无刻不在为毕业发愁。现在，想做点自己喜欢的事情，提前为明年的秋招生计做准备吧。那就先从LeetCode开始！！！</p>]]></content>
      
      
      <categories>
          
          <category> 刷题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 刷题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2019花开不败</title>
      <link href="/2019/12/18/2019-hui-geng-hao/"/>
      <url>/2019/12/18/2019-hui-geng-hao/</url>
      
        <content type="html"><![CDATA[<div align="middle"><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=407679465&auto=1&height=66"></iframe></div><p>时间过得很快，终于等到放寒假了，虽然这几个月没有课，天天和放假也没啥区别呢。细数一下，还有5个月就要毕业了吧，大一刚入学的场景却依然清楚地记得，转眼间就成了老学长了呢。闲来无事，随便写写，有感而发，无病呻吟而已。<br><img src="001.jpg" alt><br><img src="002.jpg" alt><br><img src="003.jpg" alt><br><img src="004.jpg" alt></p>]]></content>
      
      
      <categories>
          
          <category> 随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 具体生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这里的人与这里的故事</title>
      <link href="/2018/09/09/zhe-li-de-ren-yu-zhe-li-de-gu-shi/"/>
      <url>/2018/09/09/zhe-li-de-ren-yu-zhe-li-de-gu-shi/</url>
      
        <content type="html"><![CDATA[<p>&#160; &#160; &#160; &#160;在记录自己今天的感受前，先来介绍一下我大学仅有的几个好朋友之一———&gt;<strong>老郭</strong>（也就是今天的主人公李同学）！<strong>我和老郭的认识源于电子设计比赛，认知于电子设计比赛，结交于电子设计比赛，虽然我们不是一个班的，但是我们在很多问题上交流的很多，从他身上也学到了很多为人处世的道理——&gt;谦逊、踏实、担当，还有感恩！</strong><br>&#160; &#160; &#160; &#160;早上十点钟我们本来约定在大学城地铁站见面，但是很巧的是，在营口道转3号线的时候，小亮竟然与老郭完美的偶遇于一趟车的相邻车厢。（这就是缘分！哈哈！）上车后第一眼就看到了他，远远地看去，瘦了一圈，可能是来自于工作的压力人就会瘦吧！身穿一件深灰色的衬衣与牛仔裤，戴着耳机，（程序员可能都是这样的装备吧！）也在寻觅着我。老郭还是老郭，还是那样的幽默风趣，还是那样的思考着前行着前行着而又思考着，其实小亮心里一直挺为他惋惜的，但是一直又鼓励着他，让他自信起来，相信自己，不要因为过去的事带着自卑的情绪而影响现在的自己，因为你值得更好地未来，没错，你值得！！！我们俩就像失散多年的老友一样，还是当年的那个老郭与于谦，相谈甚欢。<br>&#160; &#160; &#160; &#160;到了大学城地铁站，我建议骑个小黄去学院吧，老郭说咱们走过去吧，我说好，这样也可以用脚步重新再走一遍这个地方。<strong>于是，我们就顶着今天的太阳，感受着校庆60周年的余热，北门的一句“欢迎校友回家”甚是暖心，是啊，才毕业不到三个月的我们，已然是这所大学的校友，感叹时间过得如此的飞快，老郭突然冒出一句：“下一次回到这里就不知道是什么时候了，或许在十年后吧！”我紧接着附和道：“是啊，可能是十年后了吧！”之所以与老郭的关系不断深入，就是因为知道他的每一句话背后的故事，以及他在想什么，而他所想的同时也是我想的，或许这就是我们能够说到一块的原因吧。此刻，他又在感叹，感叹曾经的故事！</strong>走在宽大的校园马路上，随处可见工大60周年校庆的牌子，还挺美的，与大家分享一下哈！<br><img src="004.jpg" alt><br>&#160; &#160; &#160; &#160;走到这里的时候，突然有三四个中年阿姨，问我们：“同学，你知道校史馆怎么走吗？”我和老郭给这些校友前辈指了校史馆的位置，老郭说要不咱们也去看看吧，之前我没去过，我说好。就这样，我们作为年轻校友在前面给校友前辈带路，到了校史馆，我和老郭在前面观看学校的历史与珍贵的仪器，顺便听讲着学生讲解员给她们的讲解。<strong>在走到一台上了年纪的纺织仪器面前，老郭出于一贯的质疑与好奇思维，尝试着搞明白它的机械原理（被我偷拍了，哈哈）</strong><br><img src="001.jpg" alt><br>&#160; &#160; &#160; &#160;<strong>还有这个—————&gt;</strong><br><img src="002.jpg" alt><br>&#160; &#160; &#160; &#160;在经过时间里程计的时候，我突然握住老郭的大手，我说一起见证这伟大的时刻吧，而老郭突然配乐道：“当当当当。。。。。。”我禁不住笑了起来，你这是瓦格纳的《婚礼进行曲》啊，有点尴尬，哈哈。<br><img src="003.jpg" alt><br>&#160; &#160; &#160; &#160;参观完校史馆，我们迫不及待的赶紧前往学院，先去了老师办公室，结果发现没人，可能是周末的原因吧。。。。。。。。然后我们就去考研自习室找了会煜大神，时间也十一点了，我们商量着要不先去吃饭去吧，就边走边聊，老郭和会煜大神谈起来更是津津有味，他们两更是同道中人。<strong>（这次回来，发现大家都没怎么变，还是老样子，真切、幽默、调侃、又互相关心着彼此的发展，或许这就是好朋友最真的面貌吧！）吃饭回来在学院一楼又聊了聊，聊到了过去，聊到了现在，还聊到了未来。</strong><br>&#160; &#160; &#160; &#160;聊到了大概十二点半左右，我和老郭看着时间也不早了，不能影响了会煜大神的节奏，我们就与他告别离开了，<strong>希望今年他能够考上自己心仪的学校，也是我们专业，甚至学院最有希望与能力的。其实，自己从他那里也学到了很多很多，做事态度认真，求真务实、追求完美、说话只说自己很有把握的话，给人一种非常踏实的感觉与印象，就是每一件事都交给他，让人很放心，而且他不仅会完成任务，而且还会给你优化与一些建议，这就是他，会煜大神，关于他的故事已然成为我们专业，乃至学院的神话，人人皆知，人人皆视其为榜样！</strong><br>&#160; &#160; &#160; &#160;再后来，我和老郭联系了一下老师，老师说他刚到办公室，我们去办公室找他，就这样，我和老郭准备了半个小时就去看望老师了。和老师谈了两三个小时，谈到了过去，谈到了现在，谈到了未来。谈到了学业、谈到了工作、谈到了个人理想。老郭又有些感触了，(我总觉得他有些不甘心，有些自卑)老师似乎也发现了，就鼓励他说其实做技术积累个两三年也挺好的，现在的研究生动手能力太差了，连最基本的仪器都不会使用，到时候找工作就不如你们这些已经工作了两三年的，只是他们起点比你们现在高罢了，老郭听后觉得也有道理，目光些许明亮起来，给老师说，他有这个自信能够在单位里做好。<strong>（以老郭的能力与思维能力，我相信三五年后，或许我该叫他李所或者李部长了。）后来又和老师聊了很多，老师也相应的给了一些建议，让我们不管在社会上还是学校里，都要实事求是，踏踏实实做技术，规划好自己的时间与人生，该来的总会来的，要懂得隐忍与坚守！！！</strong><br>&#160; &#160; &#160; &#160;四点左右，我和老郭看着时间不早了，也不想打扰老师工作（周末老师还来实验室，可见他的敬业与乐业精神所在）我们就和老师道别后，离开了。<br>&#160; &#160; &#160; &#160;<strong>最后想说，自己虽然现在已是一名研究生了，两年半后自己也面临着找工作，进入社会这个象牙塔，到时候是以怎样的姿态以及怎样的精神面貌迎接那时候的社会与工作，全在这不到三年里的每一天的进步与成长，就像老郭一样，思考着前行着前行着而又思考着，生活就是这样。人生路上能够遇到这样的恩师很难得，也很庆幸自己能够在求学路上遇见很多这样的恩师，古语云：“十年树木，百年树人；插柳之恩；终生难忘！”最后，明天是教师节，提前预祝天下的所有教师节日快乐！</strong></p><div align="right"> ——2018年9月9日夜晚 于天津大学北洋园</div>]]></content>
      
      
      <categories>
          
          <category> 朋友 人生导师 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 人生路上的朋友 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
